//! Serialize N3.
//!
//! # Variation wrt N3 syntax
//!
//! In no-strict mode (default),
//! blank node labels and quick-variables can be used as quantified names.
use super::ns::*;
use super::*;
use sophia_api::prefix::{PrefixBox, PrefixMap};
use std::io;

pub fn serialize<W: io::Write>(f: &Formula, mut config: SerializeConfig<W>) -> io::Result<()> {
    writeln!(&mut config.write, "# generated by n3r")?;
    config.serialize_prefixes()?;
    writeln!(&mut config.write)?;
    config.serialize_formula(f)
}

#[derive(Clone)]
pub struct SerializeConfig<W> {
    write: W,
    prefixes: Vec<(PrefixBox, super::Iri)>,
    initial_indent: String,
    indent: String,
    strict: bool,
    depth: usize,
}

impl<W: io::Write> SerializeConfig<W> {
    pub fn new(write: W) -> SerializeConfig<W> {
        SerializeConfig {
            write,
            prefixes: vec![
                (
                    PrefixBox::new_unchecked(Box::from("log")),
                    Iri::new_unchecked(log::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("rdf")),
                    Iri::new_unchecked(rdf::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("xsd")),
                    Iri::new_unchecked(xsd::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("v")),
                    Iri::new_unchecked(VARIABLE_NS),
                ),
            ],
            initial_indent: "".to_string(),
            indent: "    ".to_string(),
            strict: false,
            depth: 0,
        }
    }

    pub fn with_initial_indent(mut self, s: String) -> Self {
        self.initial_indent = s;
        self
    }

    pub fn with_indent(mut self, s: String) -> Self {
        self.indent = s;
        self
    }

    pub fn with_prefix(mut self, prefix: PrefixBox, ns: Iri) -> Self {
        self.prefixes.push((prefix, ns));
        self
    }

    pub fn with_prefixes(mut self, prefixes: Vec<(PrefixBox, Iri)>) -> Self {
        self.prefixes = prefixes;
        self
    }

    pub fn with_strict(mut self, b: bool) -> Self {
        self.strict = b;
        self
    }

    fn serialize_prefixes(&mut self) -> io::Result<()> {
        let Self {
            write,
            prefixes,
            initial_indent,
            ..
        } = self;
        for (pf, iri) in prefixes.iter() {
            writeln!(
                write,
                "{}PREFIX {}: <{}>",
                initial_indent,
                &pf[..],
                &iri[..]
            )?;
        }
        Ok(())
    }

    fn serialize_formula(&mut self, f: &Formula) -> io::Result<()> {
        self.depth += 1;

        let mut first = true;
        for var in f.for_all() {
            if first {
                write!(&mut self.write, "{}", self.initial_indent)?;
                write!(&mut self.write, "@forAll ?{}", var.as_str())?;
                first = false;
            } else {
                write!(&mut self.write, ", ?{}", var.as_str())?;
            }
        }
        if !first {
            writeln!(&mut self.write, ".")?;
        }

        let mut first = true;
        for var in f.for_some() {
            if first {
                write!(&mut self.write, "{}", self.initial_indent)?;
                write!(&mut self.write, "@forSome ?{}", var.as_str())?;
                first = false;
            } else {
                write!(&mut self.write, ", ?{}", var.as_str())?;
            }
        }
        if !first {
            writeln!(&mut self.write, ".")?;
        }

        for t in f.triples() {
            let i = &self.initial_indent;
            write!(&mut self.write, "{}", i)?;
            self.serialize_term(&t[0])?;
            write!(&mut self.write, " ")?;
            match &t[1] {
                Term::Iri(iri) if *iri == rdf::type_ => write!(&mut self.write, "a")?,
                Term::Iri(iri) if *iri == log::implies => write!(&mut self.write, "=>")?,
                _ => self.serialize_term(&t[1])?,
            }
            write!(&mut self.write, " ")?;
            self.serialize_term(&t[2])?;
            writeln!(&mut self.write, ".")?;
        }
        self.depth -= 1;
        Ok(())
    }

    fn serialize_term(&mut self, t: &Term) -> io::Result<()> {
        let w = &mut self.write;
        use Term::*;
        match t {
            Iri(iri) => self.serialize_iri(iri),
            Literal(CharString(val, tag)) => {
                // TODO properly serialize string, escaping characters the N3 way
                write!(w, "{:?}", val)?;
                if let Some(tag) = tag {
                    write!(w, "@{}", &tag[..])?;
                }
                Ok(())
            }
            Literal(Integer(val)) => write!(w, "{}", val),
            Literal(Double(val)) => write!(w, "{}", val),
            Literal(Boolean(val)) => write!(w, "{}", val),
            Literal(TypedLiteral(val, dt)) => {
                // TODO properly serialize string, escaping characters the N3 way
                write!(w, "{:?}^^<{}>", val, &dt[..])
            }
            Variable(var) => write!(w, "?{}", var.as_str()),
            List(terms) => {
                writeln!(&mut self.write, "( ")?;
                self.inc_indent();
                for term in terms {
                    write!(&mut self.write, "{}", &self.initial_indent)?;
                    self.serialize_term(term)?;
                    writeln!(&mut self.write)?;
                }
                self.dec_indent();
                write!(&mut self.write, "{})", self.initial_indent)
            }
            Formula(f) => {
                writeln!(&mut self.write, "{{")?;
                self.inc_indent();
                self.serialize_formula(f)?;
                self.dec_indent();
                write!(&mut self.write, "{}}}", self.initial_indent)
            }
        }
    }

    fn serialize_iri(&mut self, iri: &Iri) -> io::Result<()> {
        let Self {
            write, prefixes, ..
        } = self;
        do_serialize_iri(write, iri, &prefixes[..])
    }

    fn inc_indent(&mut self) {
        self.initial_indent.push_str(&self.indent);
    }

    fn dec_indent(&mut self) {
        self.initial_indent
            .truncate(self.initial_indent.len() - self.indent.len());
    }
}

impl Default for SerializeConfig<io::Stdout> {
    fn default() -> SerializeConfig<io::Stdout> {
        SerializeConfig::new(io::stdout())
    }
}

fn do_serialize_iri<W: io::Write, P: PrefixMap + ?Sized>(
    mut w: W,
    iri: &Iri,
    prefixes: &P,
) -> io::Result<()> {
    // TODO remove spurious space after prefixed name once the parser supports itc
    match prefixes.get_prefixed_pair(iri) {
        Some((pr, sf)) => write!(w, "{}:{}", &pr[..], sf),
        None => write!(w, "<{}>", &iri[..]),
    }
}
