//! Serialize N3.
//!
//! # Variation wrt N3 syntax
//!
//! In no-strict mode (default),
//! blank node labels and quick-variables can be used as quantified names.
use super::ns::*;
use super::*;
use sophia_api::prefix::{PrefixBox, PrefixMap};
use std::io;

pub fn serialize<W: io::Write>(f: &Formula, mut config: SerializeConfig<W>) -> io::Result<()> {
    writeln!(&mut config.write, "# generated by n3r")?;
    config.serialize_prefixes()?;
    writeln!(&mut config.write)?;
    config.serialize_formula(f)
}

#[derive(Clone)]
pub struct SerializeConfig<W> {
    write: W,
    prefixes: Vec<(PrefixBox, super::Iri)>,
    initial_indent: String,
    indent: String,
    aliases: Vec<(usize, String)>,
    strict: bool,
    depth: usize,
}

impl<W: io::Write> SerializeConfig<W> {
    pub fn new(write: W) -> SerializeConfig<W> {
        SerializeConfig {
            write,
            prefixes: vec![
                (
                    PrefixBox::new_unchecked(Box::from("log")),
                    Iri::new_unchecked(log::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("rdf")),
                    Iri::new_unchecked(rdf::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("xsd")),
                    Iri::new_unchecked(xsd::PREFIX),
                ),
                (
                    PrefixBox::new_unchecked(Box::from("v")),
                    Iri::new_unchecked(VARIABLE_NS),
                ),
            ],
            initial_indent: "".to_string(),
            indent: "    ".to_string(),
            aliases: vec![],
            strict: false,
            depth: 0,
        }
    }

    pub fn with_initial_indent(mut self, s: String) -> Self {
        self.initial_indent = s;
        self
    }

    pub fn with_indent(mut self, s: String) -> Self {
        self.indent = s;
        self
    }

    pub fn with_prefix(mut self, prefix: PrefixBox, ns: Iri) -> Self {
        self.prefixes.push((prefix, ns));
        self
    }

    pub fn with_prefixes(mut self, prefixes: Vec<(PrefixBox, Iri)>) -> Self {
        self.prefixes = prefixes;
        self
    }

    pub fn with_strict(mut self, b: bool) -> Self {
        self.strict = b;
        self
    }

    fn serialize_prefixes(&mut self) -> io::Result<()> {
        let Self {
            write,
            prefixes,
            initial_indent,
            ..
        } = self;
        for (pf, iri) in prefixes.iter() {
            writeln!(
                write,
                "{}PREFIX {}: <{}>",
                initial_indent,
                &pf[..],
                &iri[..]
            )?;
        }
        Ok(())
    }

    fn serialize_formula(&mut self, f: &Formula) -> io::Result<()> {
        let old_alias_len = self.aliases.len();
        self.depth += 1;

        let mut first = true;
        for (vid, label) in f.for_some() {
            let implicit = false; // TODO manage implicit existentials
            let alias = self.make_alias("_:", *vid, label, implicit);
            if first {
                write!(
                    &mut self.write,
                    "{}@forSome {}",
                    self.initial_indent, &alias
                )?;
                first = false;
            } else {
                write!(&mut self.write, ", {}", &alias)?;
            }
            self.aliases.push((*vid, alias));
        }
        if !first {
            writeln!(&mut self.write, ".")?;
        }

        first = true;
        for (vid, label) in f.for_all() {
            let implicit = matches!(label, VarLabel::LocalId(_)) && self.depth == 1;
            let alias = self.make_alias("?", *vid, label, implicit);
            if !implicit {
                if first {
                    write!(&mut self.write, "{}@forAll {}", self.initial_indent, &alias)?;
                    first = false;
                } else {
                    write!(&mut self.write, ", {}", &alias)?;
                }
            }
            self.aliases.push((*vid, alias));
        }
        if !first {
            writeln!(&mut self.write, ".")?;
        }

        for t in f.triples() {
            let i = &self.initial_indent;
            write!(&mut self.write, "{}", i)?;
            self.serialize_term(&t[0])?;
            write!(&mut self.write, " ")?;
            match &t[1] {
                Term::Iri(iri) if *iri == rdf::type_ => write!(&mut self.write, "a")?,
                Term::Iri(iri) if *iri == log::implies => write!(&mut self.write, "=>")?,
                _ => self.serialize_term(&t[1])?,
            }
            write!(&mut self.write, " ")?;
            self.serialize_term(&t[2])?;
            writeln!(&mut self.write, ".")?;
        }
        self.aliases.truncate(old_alias_len);
        self.depth -= 1;
        Ok(())
    }

    fn serialize_term(&mut self, t: &Term) -> io::Result<()> {
        let w = &mut self.write;
        use Term::*;
        match t {
            Iri(iri) => self.serialize_iri(iri),
            Literal(CharString(val, tag)) => {
                // TODO properly serialize string, escaping characters the N3 way
                write!(w, "{:?}", val)?;
                if let Some(tag) = tag {
                    write!(w, "@{}", &tag[..])?;
                }
                Ok(())
            }
            Literal(Integer(val)) => write!(w, "{}", val),
            Literal(Double(val)) => write!(w, "{}", val),
            Literal(Boolean(val)) => write!(w, "{}", val),
            Literal(TypedLiteral(val, dt)) => {
                // TODO properly serialize string, escaping characters the N3 way
                write!(w, "{:?}^^<{}>", val, &dt[..])
            }
            Variable(vid) => self.write_alias(*vid),
            List(terms) => {
                writeln!(&mut self.write, "( ")?;
                self.inc_indent();
                for term in terms {
                    write!(&mut self.write, "{}", &self.initial_indent)?;
                    self.serialize_term(term)?;
                    writeln!(&mut self.write)?;
                }
                self.dec_indent();
                write!(&mut self.write, "{})", self.initial_indent)
            }
            Formula(f) => {
                writeln!(&mut self.write, "{{")?;
                self.inc_indent();
                self.serialize_formula(f)?;
                self.dec_indent();
                write!(&mut self.write, "{}}}", self.initial_indent)
            }
        }
    }

    fn serialize_iri(&mut self, iri: &Iri) -> io::Result<()> {
        let Self {
            write, prefixes, ..
        } = self;
        do_serialize_iri(write, iri, &prefixes[..])
    }

    fn make_alias(&self, prefix: &str, vid: usize, label: &VarLabel, implicit: bool) -> String {
        match label {
            VarLabel::None => format!("{}v{}", prefix, vid),
            VarLabel::LocalId(id) => {
                if implicit || !self.strict {
                    format!("{}{}", prefix, &id[..])
                } else {
                    let var_iri = Iri::from_simple_iri(variable_iri(id));
                    stringify_iri(&var_iri, &self.prefixes[..])
                }
            }
            VarLabel::Iri(iri) => stringify_iri(iri, &self.prefixes[..]),
        }
    }

    fn inc_indent(&mut self) {
        self.initial_indent.push_str(&self.indent);
    }

    fn dec_indent(&mut self) {
        self.initial_indent
            .truncate(self.initial_indent.len() - self.indent.len());
    }

    /// Write to self.write the alias of variable v.
    fn write_alias(&mut self, v: usize) -> io::Result<()> {
        let Self { write, aliases, .. } = self;
        match aliases.iter().find(|(i, _)| *i == v) {
            Some((_, alias)) => write!(write, "{}", alias),
            None => write!(write, "?_free_{}", v),
        }
    }
}

impl Default for SerializeConfig<io::Stdout> {
    fn default() -> SerializeConfig<io::Stdout> {
        SerializeConfig::new(io::stdout())
    }
}

fn stringify_iri<P: PrefixMap + ?Sized>(iri: &Iri, prefixes: &P) -> String {
    let mut buf = vec![];
    do_serialize_iri(&mut buf, iri, prefixes).unwrap();
    unsafe { String::from_utf8_unchecked(buf) }
}

fn do_serialize_iri<W: io::Write, P: PrefixMap + ?Sized>(
    mut w: W,
    iri: &Iri,
    prefixes: &P,
) -> io::Result<()> {
    // TODO remove spurious space after prefixed name once the parser supports itc
    match prefixes.get_prefixed_pair(iri) {
        Some((pr, sf)) => write!(w, "{}:{} ", &pr[..], sf),
        None => write!(w, "<{}>", &iri[..]),
    }
}
